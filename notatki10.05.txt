//tworzenie requesta typu get
const Home=()=>{
	React.useEffect(()=>{
		const responce = fetch(link/?apikey=${zmienna}&s=poter&plot=full);
	};
}, []); 


http.ts //nie ma potrzeby tsx ponieważ nie ma potrzeby kompilować tego pliku jak pozostałych plików reacta

enum MethodType{
	POST='POST', //wrzucane do body
	PUT='PUT', //wrzucane do body
	GET = 'GET', //w postaci query
	DELETE='DELETE', //w postaci query
};

const requestFunction=<R>(
	url:string,
	payload:any;
	method:MethodType,
	auth:string
): Promise<R>=>{
	const options: RequestInit={
		method, //poprawne ponieważ to to samo co method:method
		...(!!auth && {		//podwójny wykrzyknik wykastowanie do wartości boolowskiej
			headers={
				Authorization: `Bearer ${auth}`, 	//zapisanie tak jakby ifa w obiekcie
			}
		}), 
	};
	let parsedUrl=url;
	
	if(method===MethodType.POST || method===MethodType.PUT && payload){
		options.body=JSON.stringify(payload);
	}
	else if(payload){
		const query = Object.keys(payload).map((key:string)=>`${key}=${payload[key]}`).join('&');
		parsedUrl=`${url}/${query}`;
	}
	return new Promise((resolve,reject)=>{
		fetch(parsedUrl,options).then(res=>res.json().then(data=>{
			if(res.status!==200)reject(Error(`Result status code of ${res.status}`;
			return data;
		})).then(json=>resolve(json)).catch(err=>reject(err));
	});
}

const http ={
	post:(url:string,payload:any,auth:string='')=>requestFunction(url,payload,MethodType.POST,auth),
	get:(url:string,payload:any,auth:string='')=>requestFunction(url,payload,MethodType.GET,auth),
	put:(url:string,payload:any,auth:string='')=>requestFunction(url,payload,MethodType.PUT,auth),
	delete:(url:string,payload:any,auth:string='')=>requestFunction(url,payload,MethodType.DELETE,auth)
}
export default http;



movies.service.ts

import http from '../utils/http';
import{omdApiKey} from '.../key';
const url='link';
const movieService={
	searchByName: async(name:string,page:number)=>{
		try{
			const responce = await <any>http.get(,{
				apikey:omdApiKey,
				s:name,
				page
			});
			if(responce?.Error){
				console.log(responce.Error);
				return null;
			}
			else{
				return{
					totalResults:parseInt(responce.totalResults, 10),
					movies: responce.Search.map((movie:any)=>({
						id:movie.imdbID,
						poster:movie.Poster,
						title:movie.Title,
						type:movie.Type,
						year:movie.Year,
					}))
				}
			}
		}
		catch(error){
			console.log(error);
		}
	},
	getById:async(id:string)=>{
		const responce=await <any>http.get(url,{
			apikey:omdApiKey,
			i:id,
		});
	}
};